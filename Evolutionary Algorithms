# Evolutionary Algorithms (EA) are a family of optimization techniques inspired by the process of biological evolution. They are used in machine learning (ML) to find optimal solutions to complex problems that are difficult to solve using traditional algorithms.

# EA works by creating a population of candidate solutions to a problem, and then using the principles of natural selection, mutation, and recombination to evolve this population towards better solutions over time. The basic steps involved in an EA are:
# Initialization: A population of individuals (candidate solutions) is randomly generated.
# Fitness evaluation: Each individual in the population is evaluated based on its fitness (i.e., how well it solves the problem).
# Selection: The fittest individuals are selected to become parents for the next generation.
# Crossover: The genetic material of the selected individuals is recombined (crossover) to produce offspring.
# Mutation: Random changes (mutation) are introduced into the genetic material of the offspring.
# Replacement: The offspring replaces the least fit individuals in the population.
# Termination: The algorithm stops when a satisfactory solution is found or a maximum number of generations is reached.

# EA can be used to solve a wide range of optimization problems, including parameter optimization, feature selection, and neural network optimization. They are particularly useful for problems with high-dimensional search spaces and non-convex objective functions.

# Here's an example Python code implementing a simple evolutionary algorithm for optimizing a mathematical function:
import random

# Define the function to be optimized
def fitness(individual):
    x, y = individual
    return -(x**2 + y**2)

# Initialize the population
population_size = 50
population = [(random.uniform(-5, 5), random.uniform(-5, 5)) for i in range(population_size)]

# Evolutionary loop
generations = 100
for generation in range(generations):
    # Evaluate the fitness of each individual
    fitnesses = [fitness(individual) for individual in population]
    # Select the fittest individuals to be parents
    parents = [population[i] for i in sorted(range(len(fitnesses)), key=lambda i: fitnesses[i])[-10:]]
    # Generate offspring by recombination and mutation
    offspring = []
    for i in range(population_size - len(parents)):
        parent1, parent2 = random.sample(parents, 2)
        offspring.append((parent1[0], parent2[1]))
    offspring = [(x + random.uniform(-0.1, 0.1), y + random.uniform(-0.1, 0.1)) for (x, y) in offspring]
    # Replace the least fit individuals with the offspring
    population = sorted(population, key=lambda x: fitness(x))
    for i in range(len(offspring)):
        population[-(i+1)] = offspring[i]

# Print the best individual found
best_individual = max(population, key=lambda x: fitness(x))
print("Best individual:", best_individual)
print("Best fitness:", fitness(best_individual))

# In this example, the algorithm optimizes the function -(x^2 + y^2) by maximizing its negative value. The population consists of 50 individuals, each represented by a pair of real numbers between -5 and 5. The fitness of each individual is evaluated using the function, and the fittest individuals are selected as parents for the next generation. Offspring are generated by recombining the genetic material of the parents and introducing random mutations, and the least fit individuals in the population are replaced with the offspring. After 100 generations, the best individual found is printed.
